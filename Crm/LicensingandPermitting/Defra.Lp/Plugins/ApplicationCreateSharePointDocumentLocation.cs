// <copyright file="ApplicationCreateSharePointDocumentLocation.cs" company="">
// Copyright (c) 2018 All Rights Reserved
// </copyright>
// <author></author>
// <date>5/18/2018 3:04:59 PM</date>
// <summary>Implements the ApplicationCreateSharePointDocumentLocation Plugin.</summary>
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1
// </auto-generated>

using System;
using Core.Helpers.Extensions;
using Lp.DataAccess;
using Lp.Model.Crm;
using Lp.Model.EarlyBound;

namespace Defra.Lp.Plugins
{
    using Core.Configuration;
    using Common.SharePoint;
    using Microsoft.Xrm.Sdk;

    /// <summary>
    /// ApplicationCreateSharePointDocumentLocation Plugin.
    /// </summary>    
    public class ApplicationCreateSharePointDocumentLocation : PluginBase
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ApplicationCreateSharePointDocumentLocation"/> class.
        /// </summary>
        /// <param name="unsecure">Contains public (unsecured) configuration information.</param>
        /// <param name="secure">Contains non-public (secured) configuration information. 
        /// When using Microsoft Dynamics 365 for Outlook with Offline Access, 
        /// the secure string is not passed to a plug-in that executes while the client is offline.</param>
        public ApplicationCreateSharePointDocumentLocation(string unsecure, string secure)
            : base(typeof(ApplicationCreateSharePointDocumentLocation))
        {
        }

        /// <summary>
        /// Main entry point for he business logic that the plug-in is to execute.
        /// </summary>
        /// <param name="localContext">The <see cref="LocalPluginContext"/> which contains the
        /// <see cref="IPluginExecutionContext"/>,
        /// <see cref="IOrganizationService"/>
        /// and <see cref="ITracingService"/>
        /// </param>
        /// <remarks>
        /// For improved performance, Microsoft Dynamics 365 caches plug-in instances.
        /// The plug-in's Execute method should be written to be stateless as the constructor
        /// is not called for every invocation of the plug-in. Also, multiple system threads
        /// could execute the plug-in at the same time. All per invocation state information
        /// is stored in the context. This means that you should not use global variables in plug-ins.
        /// </remarks>
        protected override void ExecuteCrmPlugin(LocalPluginContext localContext)
        {
            if (localContext == null)
            {
                throw new InvalidPluginExecutionException("localContext");
            }

            var context = localContext.PluginExecutionContext;
            var tracing = localContext.TracingService;
            var serviceFactory = (IOrganizationServiceFactory)localContext.ServiceProvider.GetService(typeof(IOrganizationServiceFactory));
            var adminService = serviceFactory.CreateOrganizationService(null);

            var target = (Entity)context.InputParameters["Target"];

            // Create the sharepointdocumentlocations for the permit and application
            // so that the default location create functionality is suppressed

            tracing.Trace("Getting Default Site and Permit List sharePointdocumentlocations ...");
            var Config = adminService.GetConfigurationStringValues($"{SharePointSecureConfigurationKeys.PermitListName}");
            var permitListName = Config[$"{SharePointSecureConfigurationKeys.PermitListName}"];
            tracing.Trace("Permit List Name = {0}", permitListName);

            var defaultSiteRef = adminService.FindDefaultSharePointSite();
            tracing.Trace("Default site reference = {0}", defaultSiteRef.ToString());

            var permitListRef = adminService.FindPermitListInSharePoint(defaultSiteRef.ToString(), permitListName);
            tracing.Trace("Permit List in SharePoint document location = {0}", permitListRef.ToString());

            // For a new application create a document location for both Permit and Application
            OptionSetValue applicationType = (OptionSetValue)target["defra_applicationtype"];


            // For Variations/transfers/surrenders, we link to the existing permit, unless it is a partial transfer
            if (applicationType.Value != (int) defra_ApplicationType.NewApplication)
            {
                // Use the Document Location on the Permit as the parent Document Location. It should already exist.
                tracing.Trace("Creating sharePointdocumentlocation for Application (not a new application)");
                Guid parentRef = adminService.FindPermitListInSharePoint(permitListRef.ToString(), (string)target["defra_permitnumber"]);
                tracing.Trace("Permit List in SharePoint document location = {0}", parentRef.ToString());

                // Permit document location does not exist, then create it, as required by partial transfers
                if (parentRef == Guid.Empty && applicationType.Value == (int) defra_ApplicationType.Transfer)
                {
                    // Create a document location for the permit as if it was a new application
                    CreateDocumentLocation(tracing, adminService, target, permitListRef, context);
                }
                else
                {
                    // Use the existing permit document location as a parent.
                    if (parentRef == Guid.Empty)
                    {
                        throw new InvalidPluginExecutionException($"Could not find SharePoint document location for permit number {permitListRef}.");
                    }

                    var applicationLocation = adminService.CreateApplicationDocumentLocation((string)target["defra_applicationnumber"], parentRef, target.ToEntityReference());
                    if (context.Depth <= 1)
                    {
                        tracing.Trace("Updating Application Document Location for Application Id = {0}", target.Id.ToString());
                        adminService.UpdateDocumentLocations(target, applicationLocation, null);
                    }
                }
            }
            else if (applicationType.Value == (int)defra_ApplicationType.NewApplication)
            {
                // New application gets a new permit document location
                CreateDocumentLocation(tracing, adminService, target, permitListRef, context);
            }
        }

        private static void CreateDocumentLocation(ITracingService tracing, IOrganizationService adminService, Entity target, Guid permitListRef, IPluginExecutionContext context)
        {
            string permitNumber = target.GetAttributeValue<string>("defra_permitnumber").SpRemoveIllegalChars();
            tracing.Trace($"Creating sharePointdocumentlocation for Permit {permitNumber}");
            var permitLocation = adminService.CreatePermitDocumentLocation(permitNumber, permitListRef, null);
            if (permitLocation != null)
            {

                // Now create Application document location 
                string applicationNumber = target.GetAttributeValue<string>("defra_applicationnumber").SpRemoveIllegalChars();
                tracing.Trace($"Creating sharePointdocumentlocation for Application (new application) {applicationNumber}");
                var applicationLocation =
                    adminService.CreateApplicationDocumentLocation(applicationNumber, permitLocation.Id, target.ToEntityReference());

                // Set the lookup on the Application to the Permit Document Location. Creating 
                // a new entity so as not to trigger updates on all fields. 
                tracing.Trace("Updating Application and Permit Document Location for Application Id = {0}",
                    target.Id.ToString());
                adminService.UpdateDocumentLocations(target, applicationLocation, permitLocation);
            }
        }
    }
}